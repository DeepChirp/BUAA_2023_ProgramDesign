## 题目描述

​	给出若干个端点为整数的区间（**考虑区间端点的开闭性**），请进行**区间合并**，将这些区间用最少的区间数量进行等价表示。

​	特别要注意的， $[1, 2)$ 和 $[2,3]$ 需要合并为 $[1,3]$ ， $[1, 2)$ 和 $(2,3]$ 不可以合并。

## 输入

​	若干行输入，每行一个区间

​	每行的区间由一个左括号 `[` 或 `(` ，一个整数 $l$ ，一个逗号 `,` ，一个整数 $r$ ，一个右括号 `]` 或 `)` 组成，保证 $l<r$ 

​	即输入的区间形式为 `[l,r]` , `(l,r)` ,  `[l,r)` ,  `(l,r]` 中的一种情况

## 输出

​	若干行输出，每行一个区间，表示区间合并后的结果，各个区间请按端点升序排列输出。

​	每行的区间由一个左括号 `[` 或 `(` ，一个整数 $l$ ，一个逗号 `,` ，一个整数 $r$ ，一个右括号 `]` 或 `)` 组成

## 样例

### 输入

    (10,20]
    (20,60)
    (60,100)
    [100,180]
    [-201,-200)
    [-210,-201]
    [-222,-203]

### 输出

    [-222,-200)
    (10,60)
    (60,180]

## 数据范围

​	输入的区间端点 $l, r$ 在 $int$ 范围内， $l<r$ 

​	输入区间的数量不超过 $5\times 10^5$ 个

## Hint

​	将区间按照左端点递增进行排序，然后根据右端点情况进行合并。考虑区间端点开闭性的情况下，需要对排序规则进行怎样的细微修改？排序后遍历数组，又应该怎样根据右端点的情况进行合并呢？

​	存储每个区间可能需要 $4$ 个数分别记录左右端点及其开闭性，可能需要用到二维数组存储所有区间。排序时可能需要对二维数组排序，在此给大家写一个用 `qsort` 函数排序二维数组的模板（包括 `cmp`​ 函数）：对二维数组 `int data[1000][2]` 的前 $n$ 行进行排序，排序规则为按照每行第一个元素升序排序，第一个元素相同时按照第二个元素降序排序。

    //排序规则：按照每行第一个元素升序排序，第一个元素相同时按照第二个元素升序排序
    int cmp(const void *p, const void *q) {
    	int *a = (int *)p;
    	int *b = (int *)q;
    	if(a[0] > b[0]) return 1; //第一个元素a<b，返回1表示p指向的行应该在q指向的行的后面
    	else if(a[0] < b[0]) return -1; //第一个元素a>b，返回-1表示p指向的行应该在q指向的行的前面
    	else if(a[1] < b[1]) return 1; //此时一定第一个元素a=b，判断第二个元素
    	else if((a[1] > b[1]) return -1;
    	else return 0; //第一个，第二个元素均相等，返回0表示p指向的行和q指向的行无确定前后关系
    }
    
    //调用qsort函数对二维数组int data[1000][2]前n行根据规则进行排序：
    qsort(data, n, sizeof(data[0]), cmp);



Author: 哪吒