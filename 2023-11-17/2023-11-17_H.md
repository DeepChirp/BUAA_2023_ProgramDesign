## 题目背景

散列查找是一种常用的查找方法，它的基本思想是将关键字 $key$ 作为一个函数的自变量，通过一个散列函数（也称为哈希函数）$h(x)$ 将关键字映射到一个有限的地址空间中，从而实现快速的查找。

比如一个散列函数 $h(x)$ 和有限空间的数组 $a[m]$ ，则关键字 $x$ 对应的数据存储在 $a[h(x)]$ 中。

但是由于地址空间有限，不同的关键字可能会映射到同一个地址，即 $x$ 不等于 $y$ ，但 $h(x)=h(y)$ ，这种情况称为冲突。

解决冲突的方法有很多，其中一种是线性探测法。当准备存入 $y$ 时，在 $a[h(y)]$ 位置上已经存入了 $x$ ，想要将 $y$ 存入数组而且不与 $x$ 发生冲突，则需要依次探查 $a[h(y)+1]$、$a[h(y)+2]$、........ 、$a[m-1]$、$a[0]$、$a[1]$、...... 、$a[h(y)-1]$ 直到找到一个空闲的地址。**若数组已满，则直接将 $y$ 遗弃。**



## 题目描述

现给定一个散列函数$h(x) = x\text{ } mod\text{ } m$，其中 $x$ 是一个正整数。请将一组给定的序列 $x\_1,x\_2,x\_3,......,x\_n$ 依次存入长度为 $m$ 的数组中。

若发生冲突，请用线性探测法解决冲突。最终按照数组下标从小到大的顺序输出数组元素。

## 输入

第一行 两个正整数 $m$ , $n$。保证$1\leq m\leq 1000$，$1\leq n\leq 10^5$ 。

第二行是 $n$ 个互不相同用空格隔开的正整数$x\_1,x\_2,x\_3,......,x\_n$，表示序列中的元素。保证 $x$ 在`unsigned int`范围内且均为正整数。

## 输出

输出一行，包含 $m$ 个用空格隔开的正整数，按照数组下标从小到大的顺序输出数组元素。

如果某个位置没有存储任何元素，则用 $0$ 表示。

## 输入样例


    13 7
    26 36 41 38 12 15 68 

## 输出样例


    26 12 41 15 68 0 0 0 0 0 36 0 38

## 样例解释

散列函数 $h(x) = x\text{ } mod\text{ } 13$ ，按顺序插入 $x\_1,x\_2,x\_3,......,x\_7$ ，

插入 $26$ 时，因为 $h(26) = 0$ ，所以插入数组下标为 $0$ 的位置中。

同理，依次插入 $36$ ， $41$ ， $38$ 时，分别插入到数组下标为 $10$ ，$2$ ，$12$ 的位置中。

插入 $12$ 时，因为 $h(12) = 12$ ，应当插入到数组下标为 $12$ 的位置中，但该位置已被 $38$ 所占据，因此从该位置向后依次探查寻找未被赋值的数组位置，最终找到下标为 $1$ 的位置，因此将 $12$ 存入该位置中。

最终，按照数组下标从小到大的顺序输出数组元素，得到样例输出的结果。    
Author: $pyh$