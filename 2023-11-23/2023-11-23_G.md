## 题目背景

又要考试了呢 ~ Musha 觉得自己在高中身经百战，又怎么会怕这小小的期中考试呢，呃，呃呃呃。

总之，现在她来到了考场，但是发现自己的位置上已经有人了？！

原来是老师在安排座位的时候，出了亿点点问题，很多同学拥有了相同的座位号（座位号都是正整数）。

当然了，混乱中也有着一定的规律，Musha 惊奇的发现，虽然座位号会有重复，但**不会出现空挡**。

也就是说，假设一个考场有 40 位同学，并且目前安排地座位号的最大值是 35，那么从 1 到 35 的每个每个座位号都会出现**至少一次**。

下面，Musha 想按照一定的规则，将座位号调整正确，具体方法如下：

对于每个考场，

1. 对现有座位号进行由小到大的排序，若座位号相同，按照学号由小到大的次序排序
2. 从前往后检查座位号，若某位同学的座位号**在之前出现过**，则将 TA 移到列表的最后
3. 重复上一步，直到每位同学都**被检查过**
4. 按照现在表中的次序重新填写座位号，从 1 开始，依次递增

例如：

| 座位号 | 学号 |  | 座位号 | 学号 |  | 座位号 | 学号 |  | 座位号 | 学号 |  | 座位号 | 学号 |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 2 | 22373002 |  | 1 | 22373004 |  | 1 | 22373004 |  | 1 | 22373004 |  | 1 | 22373004 |
| 2 | 22373003 |  | 2 | 22373001 |  | 2 | 22373001 |  | 2 | 22373001 |  | 2 | 22373001 |
| 1 | 22373004 |  | $\color{blue}2$ | $\color{blue}{22373002}$ |  | $\color{green}2$ | $\color{green}{22373003}$ |  | 3 | 22373006 |  | 3 | 22373006 |
| 2 | 22373001 |  | 2 | 22373003 |  | 3 | 22373006 |  | 2 | 22373002 |  | 4 | 22373002 |
| 3 | 22373006 |  | 3 | 22373006 |  | $\color{blue}2$ | $\color{blue}{22373002}$ |  | $\color{green}2$ | $\color{green}{22373003}$ |  | 5 | 22373003 |

第一列是原始座位表；第二列是排序后的结果；第三、四列表示依次将一位同学移动到队列最后的结果，移动的同学分别用蓝色和绿色字体标出；第五列为重填座位号、打印输出的结果。

## 输入格式

共 $T \times C + 1$ 行。

第一行两个整数 $T$ 与 $C$，分别表示考场数与每个考场的考生数。

接下来有 $T$ 个考场的座位安排，各 $C$ 行。每行两个整数，分别表示该生的座位号与学号。


## 输出格式

共 $T \times C$ 行。

每个考场输出 $C$ 行，每行两个整数，分别为调整后的座位号与学号，按座位号排序。座位号**按两位右对齐输出**。


## 数据范围

$1 \leqslant T \leqslant 100$，$1 \leqslant C \leqslant 50$

对于每个考场，假设座位号的最大值为 $m$，保证 $2 \leqslant m \leqslant C$，且 $1$ 至 $m$ 的座位号均存在，保证座位号为正整数

对于每个考场，保证学号不重复，且学号为 `22373` 开头的八位整数


## 输入样例

    3 4
    1 22373001
    2 22373002
    3 22373003
    4 22373004
    3 22373003
    1 22373001
    4 22373004
    2 22373002
    3 22373003
    1 22373001
    2 22373004
    2 22373002

## 输出样例

     1 22373001
     2 22373002
     3 22373003
     4 22373004
     1 22373001
     2 22373002
     3 22373003
     4 22373004
     1 22373001
     2 22373002
     3 22373003
     4 22373004

## 样例解释

共有三组数据，前两组的座位号均完全正确，没有重复，排序输出即可。第三组数据排序后的结果为：

    1 22373001
    2 22373002
    2 22373004
    3 22373003

根据规则，需要将学号为 `22373004` 的同学放到最后去，新的座位号为 `4`.

## Bug 代码

    #include <stdio.h>

    int T, count;
    int order[55], stu_id[55];

    void input(void), sort(void), solve(void), output(void);

    int main(void) {
        scanf("%d%d", &T, &count);
        while (T--) {
            input();
            sort();
            solve();
            output();
        }
        return 0;
    }

    void input(void) {
        int i;
        for (i = 0; i < count; ++i) {
            scanf("%d%d", order + i, stu_id + i);
        }
    }

    void sort(void) {
        int i, j, temp;
        for (i = 0; i < count - 1; i++) {
            for (j = 0; j < count - 1 - i; j++) {
                if (order[j] > order[j + 1] || order[j] == order[j + 1] && stu_id[j] > stu_id[j + 1]) {
                    temp = order[j + 1], order[j + 1] = order[j], order[j] = temp;
                    temp = stu_id[j + 1], stu_id[j + 1] = stu_id[j], stu_id[j] = temp;
                }
            }
        }
    }

    void solve(void) {
        int i, j, k, temp;

        int last_order = -1;
        for (i = 0; i < count; ++i) {
            if (last_order != order[i]) {
                last_order = order[i];
                continue;
            }
            int temp_order = order[i];
            int temp_id = stu_id[i];
            for (k = i + 1; k < count; ++k) {
                order[k - 1] = order[k];
                stu_id[k - 1] = stu_id[k];
            }
            order[count - 1] = temp_order;
            stu_id[count - 1] = temp_id;
        }
    }

    void output(void) {
        int i;
        for (i = 0; i < count; ++i) {
            printf("%2d %d\n", i + 1, stu_id[i]);
        }
    }


$Author:kai\\_Ker$